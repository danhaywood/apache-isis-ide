<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>6.&nbsp;Repositories, Factories and Services</title><link rel="stylesheet" href="../style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Naked Objects IDE"><link rel="up" href="ch02.html" title="Concepts"><link rel="prev" href="ch02s05.html" title="5.&nbsp;Domain Object Container"><link rel="next" href="ch02s07.html" title="7.&nbsp;Fixtures"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1130"></a>6.&nbsp;Repositories, Factories and Services</h2></div></div></div><p>Since NOA applications are ultimately <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.domaindrivendesign.org" target="_top">domain-driven</a> in nature,
      they benefit from using <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://patternshare.org/default.aspx/Home.DDD.Repositories" target="_top">repositories</a>
      (to load existing objects) and factories (to create new objects). For
      example, one might have a
      <code class="computeroutput">CustomerRepository</code> to locate existing
      <code class="computeroutput">Customer</code>s, and a
      <code class="computeroutput">CustomerFactory</code> to create new
      <code class="computeroutput">Customer</code>s.</p><p>Under NOA these repositories and factories have a special
      status:</p><div class="itemizedlist"><ul type="disc"><li><p>they are registered explicitly with the NOA implementation,
          which instantiates them once (they are singletons)</p><p>Under the Naked Objects Framework these are registered in the
          <code class="computeroutput">nakedobjects.properties</code>
          file.</p></li><li><p>they appear in the UI as "root" objects on the desktop</p><p>In the NOF's Drag-n-Drop viewer they are icons, under the web
          viewer they are links. This can be suppressed using the
          <code class="computeroutput">@Hidden</code> annotation.</p></li><li><p>methods in the repositories and factories may in the UI be
          rendered as belonging to relevant domain objects</p><p>This helps to decouples generic re-usable domain objects (eg
          <code class="computeroutput">Customer</code>) from a particular
          application context. More on this point below.</p></li><li><p>the NOA's <a href="ch02s05.html#DomainObjectContainer">Domain Object
          Container</a> injects them into any domain objects that provide
          mutator (<code class="computeroutput">setterXxx</code>) methods for
          them.</p><p>In the NOF the 'xxx' in
          <code class="computeroutput">setXxx</code> is immaterial: what matters
          is the type accepted by the setter.</p></li></ul></div><p>To amplify the 3rd point, in the example code generated by the
      <a href="ch04s01.html#ProjectWizards">project wizards</a> the
      <code class="computeroutput">OrderRepository</code> has a method
      <code class="computeroutput">findRecentOrders(Customer, Integer)</code>.
      Because one of the parameters is a
      <code class="computeroutput">Customer</code>, in the NOF it appears as a
      submenu of <code class="computeroutput">Customer</code>:</p><div class="mediaobject"><img src="resource/synthetic-methods.gif"></div><p>If this action is invoked then the NOF automatically populates
      this parameter with the <code class="computeroutput">Customer</code> object
      (since it represents the context under which the action was performed).
      These actions are sometimes called <span class="emphasis"><em>synthetic
      actions</em></span> (because they are synthesized by the UI)</p><p>Otherwise though these repository and factory objects are just
      like other domain objects in that they are rendered in the UI and can
      have actions and properties following the <a href="ch02s02.html#NO-ProgrammingModel">Naked Objects programming model</a>. In
      particular, repository and factory objects automatically have the <a href="ch02s05.html#DomainObjectContainer">Domain Object Container</a> injected
      into them.</p><p>Because repositories and factories appear directly in the UI, it
      is more usual to combine them into a single class. The Naked Objects
      application library provides a convenience superclass for this, but it
      need not be used. Usually the factory functionality is combined into the
      repository so that there is a
      <code class="computeroutput">CustomerRepository</code> which also can act
      as a factory. The example project created by the <a href="ch04s01s01.html#ApplicationProjectWizard">application project wizard</a>
      follows this approach. The <code class="computeroutput">@Named</code>
      annotation is useful also so that a more meaningful name is rendered in
      the UI (eg <code class="computeroutput">@Named("Customers")</code>.)</p><p>When developing with NOA it is common to have more than one
      implementation of the repositories. During early development/exploration
      of the domain object model naive implementations can be used that
      iterate over all objects in an in-memory object store set up by
      fixtures. Again, the example code generated by the <a href="ch04s01.html#ProjectWizards">project wizards</a> follows this approach.
      Later on these can be replaced by "real" implementations that access an
      RDBMS-based object store. Or, you can develop directly against real
      implementations. This makes fixture management and tests more complex,
      but reduces the overall amount of rework.</p><p>In fact, the NOA has a slightly more general term for repositories
      and factories: <span class="emphasis"><em>services</em></span>. Any object can be declared
      to be a service, and as such it can provide a facade to any sort of
      technical service. Examples include: sending email, generating PDFs,
      publishing messages to a message box, representing a random number
      generator. During unit testing mocks can be set up for this services,
      replaced with "real" implementations later.</p></div></body></html>